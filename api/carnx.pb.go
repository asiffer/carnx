// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.24.0-devel
// 	protoc        v3.6.1
// source: api/carnx.proto

package api

import (
	context "context"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

type Garbage struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *Garbage) Reset() {
	*x = Garbage{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_carnx_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Garbage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Garbage) ProtoMessage() {}

func (x *Garbage) ProtoReflect() protoreflect.Message {
	mi := &file_api_carnx_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Garbage.ProtoReflect.Descriptor instead.
func (*Garbage) Descriptor() ([]byte, []int) {
	return file_api_carnx_proto_rawDescGZIP(), []int{0}
}

type ReturnCode struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Code int32 `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"` // Internal function return code
}

func (x *ReturnCode) Reset() {
	*x = ReturnCode{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_carnx_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ReturnCode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReturnCode) ProtoMessage() {}

func (x *ReturnCode) ProtoReflect() protoreflect.Message {
	mi := &file_api_carnx_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReturnCode.ProtoReflect.Descriptor instead.
func (*ReturnCode) Descriptor() ([]byte, []int) {
	return file_api_carnx_proto_rawDescGZIP(), []int{1}
}

func (x *ReturnCode) GetCode() int32 {
	if x != nil {
		return x.Code
	}
	return 0
}

type NbCounters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	NbCounters uint32 `protobuf:"varint,1,opt,name=nb_counters,json=nbCounters,proto3" json:"nb_counters,omitempty"` // The number of available counters
}

func (x *NbCounters) Reset() {
	*x = NbCounters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_carnx_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NbCounters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NbCounters) ProtoMessage() {}

func (x *NbCounters) ProtoReflect() protoreflect.Message {
	mi := &file_api_carnx_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NbCounters.ProtoReflect.Descriptor instead.
func (*NbCounters) Descriptor() ([]byte, []int) {
	return file_api_carnx_proto_rawDescGZIP(), []int{2}
}

func (x *NbCounters) GetNbCounters() uint32 {
	if x != nil {
		return x.NbCounters
	}
	return 0
}

type CounterID struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"` // The raw ID of a counter
}

func (x *CounterID) Reset() {
	*x = CounterID{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_carnx_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CounterID) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CounterID) ProtoMessage() {}

func (x *CounterID) ProtoReflect() protoreflect.Message {
	mi := &file_api_carnx_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CounterID.ProtoReflect.Descriptor instead.
func (*CounterID) Descriptor() ([]byte, []int) {
	return file_api_carnx_proto_rawDescGZIP(), []int{3}
}

func (x *CounterID) GetId() uint32 {
	if x != nil {
		return x.Id
	}
	return 0
}

type CounterName struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"` // The name of the counter
}

func (x *CounterName) Reset() {
	*x = CounterName{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_carnx_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CounterName) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CounterName) ProtoMessage() {}

func (x *CounterName) ProtoReflect() protoreflect.Message {
	mi := &file_api_carnx_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CounterName.ProtoReflect.Descriptor instead.
func (*CounterName) Descriptor() ([]byte, []int) {
	return file_api_carnx_proto_rawDescGZIP(), []int{4}
}

func (x *CounterName) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type CounterValue struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Value uint64 `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"` // The Value of the counter
}

func (x *CounterValue) Reset() {
	*x = CounterValue{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_carnx_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CounterValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CounterValue) ProtoMessage() {}

func (x *CounterValue) ProtoReflect() protoreflect.Message {
	mi := &file_api_carnx_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CounterValue.ProtoReflect.Descriptor instead.
func (*CounterValue) Descriptor() ([]byte, []int) {
	return file_api_carnx_proto_rawDescGZIP(), []int{5}
}

func (x *CounterValue) GetValue() uint64 {
	if x != nil {
		return x.Value
	}
	return 0
}

type CounterList struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Counters []string `protobuf:"bytes,1,rep,name=counters,proto3" json:"counters,omitempty"` // A list of counter names
}

func (x *CounterList) Reset() {
	*x = CounterList{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_carnx_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CounterList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CounterList) ProtoMessage() {}

func (x *CounterList) ProtoReflect() protoreflect.Message {
	mi := &file_api_carnx_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CounterList.ProtoReflect.Descriptor instead.
func (*CounterList) Descriptor() ([]byte, []int) {
	return file_api_carnx_proto_rawDescGZIP(), []int{6}
}

func (x *CounterList) GetCounters() []string {
	if x != nil {
		return x.Counters
	}
	return nil
}

type Snap struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Data map[string]uint64 `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"` // Counter Name->Value mapping
}

func (x *Snap) Reset() {
	*x = Snap{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_carnx_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Snap) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Snap) ProtoMessage() {}

func (x *Snap) ProtoReflect() protoreflect.Message {
	mi := &file_api_carnx_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Snap.ProtoReflect.Descriptor instead.
func (*Snap) Descriptor() ([]byte, []int) {
	return file_api_carnx_proto_rawDescGZIP(), []int{7}
}

func (x *Snap) GetData() map[string]uint64 {
	if x != nil {
		return x.Data
	}
	return nil
}

type AttachParameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Interface string `protobuf:"bytes,1,opt,name=interface,proto3" json:"interface,omitempty"`                // Name of the network interface
	XdpFlags  uint32 `protobuf:"varint,2,opt,name=xdp_flags,json=xdpFlags,proto3" json:"xdp_flags,omitempty"` // XDP attaching flags
}

func (x *AttachParameters) Reset() {
	*x = AttachParameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_carnx_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AttachParameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttachParameters) ProtoMessage() {}

func (x *AttachParameters) ProtoReflect() protoreflect.Message {
	mi := &file_api_carnx_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AttachParameters.ProtoReflect.Descriptor instead.
func (*AttachParameters) Descriptor() ([]byte, []int) {
	return file_api_carnx_proto_rawDescGZIP(), []int{8}
}

func (x *AttachParameters) GetInterface() string {
	if x != nil {
		return x.Interface
	}
	return ""
}

func (x *AttachParameters) GetXdpFlags() uint32 {
	if x != nil {
		return x.XdpFlags
	}
	return 0
}

type LoadAttachParameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Interface  string `protobuf:"bytes,1,opt,name=interface,proto3" json:"interface,omitempty"`                     // Name of the network interface
	XdpFlags   uint32 `protobuf:"varint,2,opt,name=xdp_flags,json=xdpFlags,proto3" json:"xdp_flags,omitempty"`      // XDP attaching flags
	BpfProgram string `protobuf:"bytes,3,opt,name=bpf_program,json=bpfProgram,proto3" json:"bpf_program,omitempty"` // Path to the eBPF program
}

func (x *LoadAttachParameters) Reset() {
	*x = LoadAttachParameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_carnx_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadAttachParameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadAttachParameters) ProtoMessage() {}

func (x *LoadAttachParameters) ProtoReflect() protoreflect.Message {
	mi := &file_api_carnx_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadAttachParameters.ProtoReflect.Descriptor instead.
func (*LoadAttachParameters) Descriptor() ([]byte, []int) {
	return file_api_carnx_proto_rawDescGZIP(), []int{9}
}

func (x *LoadAttachParameters) GetInterface() string {
	if x != nil {
		return x.Interface
	}
	return ""
}

func (x *LoadAttachParameters) GetXdpFlags() uint32 {
	if x != nil {
		return x.XdpFlags
	}
	return 0
}

func (x *LoadAttachParameters) GetBpfProgram() string {
	if x != nil {
		return x.BpfProgram
	}
	return ""
}

type LoadParameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	BpfProgram string `protobuf:"bytes,1,opt,name=bpf_program,json=bpfProgram,proto3" json:"bpf_program,omitempty"` // Path of the BPF program
}

func (x *LoadParameters) Reset() {
	*x = LoadParameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_carnx_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadParameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadParameters) ProtoMessage() {}

func (x *LoadParameters) ProtoReflect() protoreflect.Message {
	mi := &file_api_carnx_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadParameters.ProtoReflect.Descriptor instead.
func (*LoadParameters) Descriptor() ([]byte, []int) {
	return file_api_carnx_proto_rawDescGZIP(), []int{10}
}

func (x *LoadParameters) GetBpfProgram() string {
	if x != nil {
		return x.BpfProgram
	}
	return ""
}

type LoadStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Loaded bool `protobuf:"varint,1,opt,name=loaded,proto3" json:"loaded,omitempty"` // Status of the BPF program
}

func (x *LoadStatus) Reset() {
	*x = LoadStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_carnx_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadStatus) ProtoMessage() {}

func (x *LoadStatus) ProtoReflect() protoreflect.Message {
	mi := &file_api_carnx_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadStatus.ProtoReflect.Descriptor instead.
func (*LoadStatus) Descriptor() ([]byte, []int) {
	return file_api_carnx_proto_rawDescGZIP(), []int{11}
}

func (x *LoadStatus) GetLoaded() bool {
	if x != nil {
		return x.Loaded
	}
	return false
}

type AttachStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Attached bool `protobuf:"varint,1,opt,name=attached,proto3" json:"attached,omitempty"` // Status of the BPF program
}

func (x *AttachStatus) Reset() {
	*x = AttachStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_carnx_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AttachStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttachStatus) ProtoMessage() {}

func (x *AttachStatus) ProtoReflect() protoreflect.Message {
	mi := &file_api_carnx_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AttachStatus.ProtoReflect.Descriptor instead.
func (*AttachStatus) Descriptor() ([]byte, []int) {
	return file_api_carnx_proto_rawDescGZIP(), []int{12}
}

func (x *AttachStatus) GetAttached() bool {
	if x != nil {
		return x.Attached
	}
	return false
}

var File_api_carnx_proto protoreflect.FileDescriptor

var file_api_carnx_proto_rawDesc = []byte{
	0x0a, 0x0f, 0x61, 0x70, 0x69, 0x2f, 0x63, 0x61, 0x72, 0x6e, 0x78, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x12, 0x03, 0x61, 0x70, 0x69, 0x22, 0x09, 0x0a, 0x07, 0x47, 0x61, 0x72, 0x62, 0x61, 0x67,
	0x65, 0x22, 0x20, 0x0a, 0x0a, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x43, 0x6f, 0x64, 0x65, 0x12,
	0x12, 0x0a, 0x04, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x04, 0x63,
	0x6f, 0x64, 0x65, 0x22, 0x2d, 0x0a, 0x0a, 0x4e, 0x62, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72,
	0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x6e, 0x62, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x73,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0a, 0x6e, 0x62, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x65,
	0x72, 0x73, 0x22, 0x1b, 0x0a, 0x09, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x49, 0x44, 0x12,
	0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x69, 0x64, 0x22,
	0x21, 0x0a, 0x0b, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x12,
	0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61,
	0x6d, 0x65, 0x22, 0x24, 0x0a, 0x0c, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x56, 0x61, 0x6c,
	0x75, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x04, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x29, 0x0a, 0x0b, 0x43, 0x6f, 0x75, 0x6e,
	0x74, 0x65, 0x72, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x63, 0x6f, 0x75, 0x6e, 0x74,
	0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x08, 0x63, 0x6f, 0x75, 0x6e, 0x74,
	0x65, 0x72, 0x73, 0x22, 0x68, 0x0a, 0x04, 0x53, 0x6e, 0x61, 0x70, 0x12, 0x27, 0x0a, 0x04, 0x64,
	0x61, 0x74, 0x61, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x61, 0x70, 0x69, 0x2e,
	0x53, 0x6e, 0x61, 0x70, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x04,
	0x64, 0x61, 0x74, 0x61, 0x1a, 0x37, 0x0a, 0x09, 0x44, 0x61, 0x74, 0x61, 0x45, 0x6e, 0x74, 0x72,
	0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03,
	0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x04, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x4d, 0x0a,
	0x10, 0x41, 0x74, 0x74, 0x61, 0x63, 0x68, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72,
	0x73, 0x12, 0x1c, 0x0a, 0x09, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x12,
	0x1b, 0x0a, 0x09, 0x78, 0x64, 0x70, 0x5f, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x08, 0x78, 0x64, 0x70, 0x46, 0x6c, 0x61, 0x67, 0x73, 0x22, 0x72, 0x0a, 0x14,
	0x4c, 0x6f, 0x61, 0x64, 0x41, 0x74, 0x74, 0x61, 0x63, 0x68, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65,
	0x74, 0x65, 0x72, 0x73, 0x12, 0x1c, 0x0a, 0x09, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63,
	0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61,
	0x63, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x78, 0x64, 0x70, 0x5f, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x08, 0x78, 0x64, 0x70, 0x46, 0x6c, 0x61, 0x67, 0x73, 0x12,
	0x1f, 0x0a, 0x0b, 0x62, 0x70, 0x66, 0x5f, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61, 0x6d, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x62, 0x70, 0x66, 0x50, 0x72, 0x6f, 0x67, 0x72, 0x61, 0x6d,
	0x22, 0x31, 0x0a, 0x0e, 0x4c, 0x6f, 0x61, 0x64, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65,
	0x72, 0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x62, 0x70, 0x66, 0x5f, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,
	0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x62, 0x70, 0x66, 0x50, 0x72, 0x6f, 0x67,
	0x72, 0x61, 0x6d, 0x22, 0x24, 0x0a, 0x0a, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x12, 0x16, 0x0a, 0x06, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x08, 0x52, 0x06, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x64, 0x22, 0x2a, 0x0a, 0x0c, 0x41, 0x74, 0x74,
	0x61, 0x63, 0x68, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x61, 0x74, 0x74,
	0x61, 0x63, 0x68, 0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x61, 0x74, 0x74,
	0x61, 0x63, 0x68, 0x65, 0x64, 0x32, 0x80, 0x05, 0x0a, 0x05, 0x43, 0x61, 0x72, 0x6e, 0x78, 0x12,
	0x30, 0x0a, 0x0d, 0x47, 0x65, 0x74, 0x4e, 0x62, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x73,
	0x12, 0x0c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x47, 0x61, 0x72, 0x62, 0x61, 0x67, 0x65, 0x1a, 0x0f,
	0x2e, 0x61, 0x70, 0x69, 0x2e, 0x4e, 0x62, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x73, 0x22,
	0x00, 0x12, 0x24, 0x0a, 0x04, 0x50, 0x69, 0x6e, 0x67, 0x12, 0x0c, 0x2e, 0x61, 0x70, 0x69, 0x2e,
	0x47, 0x61, 0x72, 0x62, 0x61, 0x67, 0x65, 0x1a, 0x0c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x47, 0x61,
	0x72, 0x62, 0x61, 0x67, 0x65, 0x22, 0x00, 0x12, 0x31, 0x0a, 0x0a, 0x47, 0x65, 0x74, 0x43, 0x6f,
	0x75, 0x6e, 0x74, 0x65, 0x72, 0x12, 0x0e, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x43, 0x6f, 0x75, 0x6e,
	0x74, 0x65, 0x72, 0x49, 0x44, 0x1a, 0x11, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x43, 0x6f, 0x75, 0x6e,
	0x74, 0x65, 0x72, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x00, 0x12, 0x39, 0x0a, 0x10, 0x47, 0x65,
	0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x42, 0x79, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x10,
	0x2e, 0x61, 0x70, 0x69, 0x2e, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x4e, 0x61, 0x6d, 0x65,
	0x1a, 0x11, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x56, 0x61,
	0x6c, 0x75, 0x65, 0x22, 0x00, 0x12, 0x33, 0x0a, 0x0f, 0x47, 0x65, 0x74, 0x43, 0x6f, 0x75, 0x6e,
	0x74, 0x65, 0x72, 0x4e, 0x61, 0x6d, 0x65, 0x73, 0x12, 0x0c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x47,
	0x61, 0x72, 0x62, 0x61, 0x67, 0x65, 0x1a, 0x10, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x43, 0x6f, 0x75,
	0x6e, 0x74, 0x65, 0x72, 0x4c, 0x69, 0x73, 0x74, 0x22, 0x00, 0x12, 0x25, 0x0a, 0x08, 0x53, 0x6e,
	0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x12, 0x0c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x47, 0x61, 0x72,
	0x62, 0x61, 0x67, 0x65, 0x1a, 0x09, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x6e, 0x61, 0x70, 0x22,
	0x00, 0x12, 0x2e, 0x0a, 0x04, 0x4c, 0x6f, 0x61, 0x64, 0x12, 0x13, 0x2e, 0x61, 0x70, 0x69, 0x2e,
	0x4c, 0x6f, 0x61, 0x64, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x1a, 0x0f,
	0x2e, 0x61, 0x70, 0x69, 0x2e, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x43, 0x6f, 0x64, 0x65, 0x22,
	0x00, 0x12, 0x3d, 0x0a, 0x0d, 0x4c, 0x6f, 0x61, 0x64, 0x41, 0x6e, 0x64, 0x41, 0x74, 0x74, 0x61,
	0x63, 0x68, 0x12, 0x19, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x41, 0x74, 0x74,
	0x61, 0x63, 0x68, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x1a, 0x0f, 0x2e,
	0x61, 0x70, 0x69, 0x2e, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x43, 0x6f, 0x64, 0x65, 0x22, 0x00,
	0x12, 0x29, 0x0a, 0x06, 0x55, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x12, 0x0c, 0x2e, 0x61, 0x70, 0x69,
	0x2e, 0x47, 0x61, 0x72, 0x62, 0x61, 0x67, 0x65, 0x1a, 0x0f, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x52,
	0x65, 0x74, 0x75, 0x72, 0x6e, 0x43, 0x6f, 0x64, 0x65, 0x22, 0x00, 0x12, 0x32, 0x0a, 0x06, 0x41,
	0x74, 0x74, 0x61, 0x63, 0x68, 0x12, 0x15, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x41, 0x74, 0x74, 0x61,
	0x63, 0x68, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x1a, 0x0f, 0x2e, 0x61,
	0x70, 0x69, 0x2e, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x43, 0x6f, 0x64, 0x65, 0x22, 0x00, 0x12,
	0x29, 0x0a, 0x06, 0x44, 0x65, 0x74, 0x61, 0x63, 0x68, 0x12, 0x0c, 0x2e, 0x61, 0x70, 0x69, 0x2e,
	0x47, 0x61, 0x72, 0x62, 0x61, 0x67, 0x65, 0x1a, 0x0f, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x52, 0x65,
	0x74, 0x75, 0x72, 0x6e, 0x43, 0x6f, 0x64, 0x65, 0x22, 0x00, 0x12, 0x2b, 0x0a, 0x08, 0x49, 0x73,
	0x4c, 0x6f, 0x61, 0x64, 0x65, 0x64, 0x12, 0x0c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x47, 0x61, 0x72,
	0x62, 0x61, 0x67, 0x65, 0x1a, 0x0f, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x53,
	0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x00, 0x12, 0x2f, 0x0a, 0x0a, 0x49, 0x73, 0x41, 0x74, 0x74,
	0x61, 0x63, 0x68, 0x65, 0x64, 0x12, 0x0c, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x47, 0x61, 0x72, 0x62,
	0x61, 0x67, 0x65, 0x1a, 0x11, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x41, 0x74, 0x74, 0x61, 0x63, 0x68,
	0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x00, 0x42, 0x0b, 0x5a, 0x09, 0x63, 0x61, 0x72, 0x6e,
	0x78, 0x2f, 0x61, 0x70, 0x69, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_api_carnx_proto_rawDescOnce sync.Once
	file_api_carnx_proto_rawDescData = file_api_carnx_proto_rawDesc
)

func file_api_carnx_proto_rawDescGZIP() []byte {
	file_api_carnx_proto_rawDescOnce.Do(func() {
		file_api_carnx_proto_rawDescData = protoimpl.X.CompressGZIP(file_api_carnx_proto_rawDescData)
	})
	return file_api_carnx_proto_rawDescData
}

var file_api_carnx_proto_msgTypes = make([]protoimpl.MessageInfo, 14)
var file_api_carnx_proto_goTypes = []interface{}{
	(*Garbage)(nil),              // 0: api.Garbage
	(*ReturnCode)(nil),           // 1: api.ReturnCode
	(*NbCounters)(nil),           // 2: api.NbCounters
	(*CounterID)(nil),            // 3: api.CounterID
	(*CounterName)(nil),          // 4: api.CounterName
	(*CounterValue)(nil),         // 5: api.CounterValue
	(*CounterList)(nil),          // 6: api.CounterList
	(*Snap)(nil),                 // 7: api.Snap
	(*AttachParameters)(nil),     // 8: api.AttachParameters
	(*LoadAttachParameters)(nil), // 9: api.LoadAttachParameters
	(*LoadParameters)(nil),       // 10: api.LoadParameters
	(*LoadStatus)(nil),           // 11: api.LoadStatus
	(*AttachStatus)(nil),         // 12: api.AttachStatus
	nil,                          // 13: api.Snap.DataEntry
}
var file_api_carnx_proto_depIdxs = []int32{
	13, // 0: api.Snap.data:type_name -> api.Snap.DataEntry
	0,  // 1: api.Carnx.GetNbCounters:input_type -> api.Garbage
	0,  // 2: api.Carnx.Ping:input_type -> api.Garbage
	3,  // 3: api.Carnx.GetCounter:input_type -> api.CounterID
	4,  // 4: api.Carnx.GetCounterByName:input_type -> api.CounterName
	0,  // 5: api.Carnx.GetCounterNames:input_type -> api.Garbage
	0,  // 6: api.Carnx.Snapshot:input_type -> api.Garbage
	10, // 7: api.Carnx.Load:input_type -> api.LoadParameters
	9,  // 8: api.Carnx.LoadAndAttach:input_type -> api.LoadAttachParameters
	0,  // 9: api.Carnx.Unload:input_type -> api.Garbage
	8,  // 10: api.Carnx.Attach:input_type -> api.AttachParameters
	0,  // 11: api.Carnx.Detach:input_type -> api.Garbage
	0,  // 12: api.Carnx.IsLoaded:input_type -> api.Garbage
	0,  // 13: api.Carnx.IsAttached:input_type -> api.Garbage
	2,  // 14: api.Carnx.GetNbCounters:output_type -> api.NbCounters
	0,  // 15: api.Carnx.Ping:output_type -> api.Garbage
	5,  // 16: api.Carnx.GetCounter:output_type -> api.CounterValue
	5,  // 17: api.Carnx.GetCounterByName:output_type -> api.CounterValue
	6,  // 18: api.Carnx.GetCounterNames:output_type -> api.CounterList
	7,  // 19: api.Carnx.Snapshot:output_type -> api.Snap
	1,  // 20: api.Carnx.Load:output_type -> api.ReturnCode
	1,  // 21: api.Carnx.LoadAndAttach:output_type -> api.ReturnCode
	1,  // 22: api.Carnx.Unload:output_type -> api.ReturnCode
	1,  // 23: api.Carnx.Attach:output_type -> api.ReturnCode
	1,  // 24: api.Carnx.Detach:output_type -> api.ReturnCode
	11, // 25: api.Carnx.IsLoaded:output_type -> api.LoadStatus
	12, // 26: api.Carnx.IsAttached:output_type -> api.AttachStatus
	14, // [14:27] is the sub-list for method output_type
	1,  // [1:14] is the sub-list for method input_type
	1,  // [1:1] is the sub-list for extension type_name
	1,  // [1:1] is the sub-list for extension extendee
	0,  // [0:1] is the sub-list for field type_name
}

func init() { file_api_carnx_proto_init() }
func file_api_carnx_proto_init() {
	if File_api_carnx_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_api_carnx_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Garbage); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_carnx_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ReturnCode); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_carnx_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NbCounters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_carnx_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CounterID); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_carnx_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CounterName); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_carnx_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CounterValue); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_carnx_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CounterList); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_carnx_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Snap); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_carnx_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AttachParameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_carnx_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadAttachParameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_carnx_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadParameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_carnx_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_carnx_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AttachStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_api_carnx_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   14,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_api_carnx_proto_goTypes,
		DependencyIndexes: file_api_carnx_proto_depIdxs,
		MessageInfos:      file_api_carnx_proto_msgTypes,
	}.Build()
	File_api_carnx_proto = out.File
	file_api_carnx_proto_rawDesc = nil
	file_api_carnx_proto_goTypes = nil
	file_api_carnx_proto_depIdxs = nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// CarnxClient is the client API for Carnx service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CarnxClient interface {
	// GetNbCounters returns the number of counters
	GetNbCounters(ctx context.Context, in *Garbage, opts ...grpc.CallOption) (*NbCounters, error)
	// Ping aims to check the connection
	Ping(ctx context.Context, in *Garbage, opts ...grpc.CallOption) (*Garbage, error)
	// GetCounter returns the value of a counter given its key
	GetCounter(ctx context.Context, in *CounterID, opts ...grpc.CallOption) (*CounterValue, error)
	// GetCounterByName returns the value of a counter given its name
	GetCounterByName(ctx context.Context, in *CounterName, opts ...grpc.CallOption) (*CounterValue, error)
	// GetCounterNames returns the list of the counters (in the right order)
	GetCounterNames(ctx context.Context, in *Garbage, opts ...grpc.CallOption) (*CounterList, error)
	// Snapshot returns the current values of the counters
	Snapshot(ctx context.Context, in *Garbage, opts ...grpc.CallOption) (*Snap, error)
	// Load an eBPF program into the kernel
	Load(ctx context.Context, in *LoadParameters, opts ...grpc.CallOption) (*ReturnCode, error)
	// LoadAndAttach aims to init the XDP program. It loads the program
	// into the kernel and attach it to the given interface with
	// the given flags
	LoadAndAttach(ctx context.Context, in *LoadAttachParameters, opts ...grpc.CallOption) (*ReturnCode, error)
	// Unload the eBPF program from the kernel
	Unload(ctx context.Context, in *Garbage, opts ...grpc.CallOption) (*ReturnCode, error)
	// Attach the XDP program onto the given interface
	Attach(ctx context.Context, in *AttachParameters, opts ...grpc.CallOption) (*ReturnCode, error)
	// Detach the XDP program from the interface previously given
	Detach(ctx context.Context, in *Garbage, opts ...grpc.CallOption) (*ReturnCode, error)
	// IsLoaded check if the program is loaded into the kernel
	IsLoaded(ctx context.Context, in *Garbage, opts ...grpc.CallOption) (*LoadStatus, error)
	// IsAttached check if the program is attached to the interface
	IsAttached(ctx context.Context, in *Garbage, opts ...grpc.CallOption) (*AttachStatus, error)
}

type carnxClient struct {
	cc grpc.ClientConnInterface
}

func NewCarnxClient(cc grpc.ClientConnInterface) CarnxClient {
	return &carnxClient{cc}
}

func (c *carnxClient) GetNbCounters(ctx context.Context, in *Garbage, opts ...grpc.CallOption) (*NbCounters, error) {
	out := new(NbCounters)
	err := c.cc.Invoke(ctx, "/api.Carnx/GetNbCounters", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *carnxClient) Ping(ctx context.Context, in *Garbage, opts ...grpc.CallOption) (*Garbage, error) {
	out := new(Garbage)
	err := c.cc.Invoke(ctx, "/api.Carnx/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *carnxClient) GetCounter(ctx context.Context, in *CounterID, opts ...grpc.CallOption) (*CounterValue, error) {
	out := new(CounterValue)
	err := c.cc.Invoke(ctx, "/api.Carnx/GetCounter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *carnxClient) GetCounterByName(ctx context.Context, in *CounterName, opts ...grpc.CallOption) (*CounterValue, error) {
	out := new(CounterValue)
	err := c.cc.Invoke(ctx, "/api.Carnx/GetCounterByName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *carnxClient) GetCounterNames(ctx context.Context, in *Garbage, opts ...grpc.CallOption) (*CounterList, error) {
	out := new(CounterList)
	err := c.cc.Invoke(ctx, "/api.Carnx/GetCounterNames", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *carnxClient) Snapshot(ctx context.Context, in *Garbage, opts ...grpc.CallOption) (*Snap, error) {
	out := new(Snap)
	err := c.cc.Invoke(ctx, "/api.Carnx/Snapshot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *carnxClient) Load(ctx context.Context, in *LoadParameters, opts ...grpc.CallOption) (*ReturnCode, error) {
	out := new(ReturnCode)
	err := c.cc.Invoke(ctx, "/api.Carnx/Load", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *carnxClient) LoadAndAttach(ctx context.Context, in *LoadAttachParameters, opts ...grpc.CallOption) (*ReturnCode, error) {
	out := new(ReturnCode)
	err := c.cc.Invoke(ctx, "/api.Carnx/LoadAndAttach", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *carnxClient) Unload(ctx context.Context, in *Garbage, opts ...grpc.CallOption) (*ReturnCode, error) {
	out := new(ReturnCode)
	err := c.cc.Invoke(ctx, "/api.Carnx/Unload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *carnxClient) Attach(ctx context.Context, in *AttachParameters, opts ...grpc.CallOption) (*ReturnCode, error) {
	out := new(ReturnCode)
	err := c.cc.Invoke(ctx, "/api.Carnx/Attach", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *carnxClient) Detach(ctx context.Context, in *Garbage, opts ...grpc.CallOption) (*ReturnCode, error) {
	out := new(ReturnCode)
	err := c.cc.Invoke(ctx, "/api.Carnx/Detach", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *carnxClient) IsLoaded(ctx context.Context, in *Garbage, opts ...grpc.CallOption) (*LoadStatus, error) {
	out := new(LoadStatus)
	err := c.cc.Invoke(ctx, "/api.Carnx/IsLoaded", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *carnxClient) IsAttached(ctx context.Context, in *Garbage, opts ...grpc.CallOption) (*AttachStatus, error) {
	out := new(AttachStatus)
	err := c.cc.Invoke(ctx, "/api.Carnx/IsAttached", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CarnxServer is the server API for Carnx service.
type CarnxServer interface {
	// GetNbCounters returns the number of counters
	GetNbCounters(context.Context, *Garbage) (*NbCounters, error)
	// Ping aims to check the connection
	Ping(context.Context, *Garbage) (*Garbage, error)
	// GetCounter returns the value of a counter given its key
	GetCounter(context.Context, *CounterID) (*CounterValue, error)
	// GetCounterByName returns the value of a counter given its name
	GetCounterByName(context.Context, *CounterName) (*CounterValue, error)
	// GetCounterNames returns the list of the counters (in the right order)
	GetCounterNames(context.Context, *Garbage) (*CounterList, error)
	// Snapshot returns the current values of the counters
	Snapshot(context.Context, *Garbage) (*Snap, error)
	// Load an eBPF program into the kernel
	Load(context.Context, *LoadParameters) (*ReturnCode, error)
	// LoadAndAttach aims to init the XDP program. It loads the program
	// into the kernel and attach it to the given interface with
	// the given flags
	LoadAndAttach(context.Context, *LoadAttachParameters) (*ReturnCode, error)
	// Unload the eBPF program from the kernel
	Unload(context.Context, *Garbage) (*ReturnCode, error)
	// Attach the XDP program onto the given interface
	Attach(context.Context, *AttachParameters) (*ReturnCode, error)
	// Detach the XDP program from the interface previously given
	Detach(context.Context, *Garbage) (*ReturnCode, error)
	// IsLoaded check if the program is loaded into the kernel
	IsLoaded(context.Context, *Garbage) (*LoadStatus, error)
	// IsAttached check if the program is attached to the interface
	IsAttached(context.Context, *Garbage) (*AttachStatus, error)
}

// UnimplementedCarnxServer can be embedded to have forward compatible implementations.
type UnimplementedCarnxServer struct {
}

func (*UnimplementedCarnxServer) GetNbCounters(context.Context, *Garbage) (*NbCounters, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNbCounters not implemented")
}
func (*UnimplementedCarnxServer) Ping(context.Context, *Garbage) (*Garbage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (*UnimplementedCarnxServer) GetCounter(context.Context, *CounterID) (*CounterValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCounter not implemented")
}
func (*UnimplementedCarnxServer) GetCounterByName(context.Context, *CounterName) (*CounterValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCounterByName not implemented")
}
func (*UnimplementedCarnxServer) GetCounterNames(context.Context, *Garbage) (*CounterList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCounterNames not implemented")
}
func (*UnimplementedCarnxServer) Snapshot(context.Context, *Garbage) (*Snap, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Snapshot not implemented")
}
func (*UnimplementedCarnxServer) Load(context.Context, *LoadParameters) (*ReturnCode, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Load not implemented")
}
func (*UnimplementedCarnxServer) LoadAndAttach(context.Context, *LoadAttachParameters) (*ReturnCode, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadAndAttach not implemented")
}
func (*UnimplementedCarnxServer) Unload(context.Context, *Garbage) (*ReturnCode, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unload not implemented")
}
func (*UnimplementedCarnxServer) Attach(context.Context, *AttachParameters) (*ReturnCode, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Attach not implemented")
}
func (*UnimplementedCarnxServer) Detach(context.Context, *Garbage) (*ReturnCode, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Detach not implemented")
}
func (*UnimplementedCarnxServer) IsLoaded(context.Context, *Garbage) (*LoadStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsLoaded not implemented")
}
func (*UnimplementedCarnxServer) IsAttached(context.Context, *Garbage) (*AttachStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsAttached not implemented")
}

func RegisterCarnxServer(s *grpc.Server, srv CarnxServer) {
	s.RegisterService(&_Carnx_serviceDesc, srv)
}

func _Carnx_GetNbCounters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Garbage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarnxServer).GetNbCounters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Carnx/GetNbCounters",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarnxServer).GetNbCounters(ctx, req.(*Garbage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Carnx_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Garbage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarnxServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Carnx/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarnxServer).Ping(ctx, req.(*Garbage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Carnx_GetCounter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CounterID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarnxServer).GetCounter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Carnx/GetCounter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarnxServer).GetCounter(ctx, req.(*CounterID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Carnx_GetCounterByName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CounterName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarnxServer).GetCounterByName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Carnx/GetCounterByName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarnxServer).GetCounterByName(ctx, req.(*CounterName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Carnx_GetCounterNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Garbage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarnxServer).GetCounterNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Carnx/GetCounterNames",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarnxServer).GetCounterNames(ctx, req.(*Garbage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Carnx_Snapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Garbage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarnxServer).Snapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Carnx/Snapshot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarnxServer).Snapshot(ctx, req.(*Garbage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Carnx_Load_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadParameters)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarnxServer).Load(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Carnx/Load",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarnxServer).Load(ctx, req.(*LoadParameters))
	}
	return interceptor(ctx, in, info, handler)
}

func _Carnx_LoadAndAttach_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadAttachParameters)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarnxServer).LoadAndAttach(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Carnx/LoadAndAttach",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarnxServer).LoadAndAttach(ctx, req.(*LoadAttachParameters))
	}
	return interceptor(ctx, in, info, handler)
}

func _Carnx_Unload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Garbage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarnxServer).Unload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Carnx/Unload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarnxServer).Unload(ctx, req.(*Garbage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Carnx_Attach_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachParameters)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarnxServer).Attach(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Carnx/Attach",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarnxServer).Attach(ctx, req.(*AttachParameters))
	}
	return interceptor(ctx, in, info, handler)
}

func _Carnx_Detach_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Garbage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarnxServer).Detach(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Carnx/Detach",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarnxServer).Detach(ctx, req.(*Garbage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Carnx_IsLoaded_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Garbage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarnxServer).IsLoaded(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Carnx/IsLoaded",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarnxServer).IsLoaded(ctx, req.(*Garbage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Carnx_IsAttached_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Garbage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarnxServer).IsAttached(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Carnx/IsAttached",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarnxServer).IsAttached(ctx, req.(*Garbage))
	}
	return interceptor(ctx, in, info, handler)
}

var _Carnx_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Carnx",
	HandlerType: (*CarnxServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetNbCounters",
			Handler:    _Carnx_GetNbCounters_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _Carnx_Ping_Handler,
		},
		{
			MethodName: "GetCounter",
			Handler:    _Carnx_GetCounter_Handler,
		},
		{
			MethodName: "GetCounterByName",
			Handler:    _Carnx_GetCounterByName_Handler,
		},
		{
			MethodName: "GetCounterNames",
			Handler:    _Carnx_GetCounterNames_Handler,
		},
		{
			MethodName: "Snapshot",
			Handler:    _Carnx_Snapshot_Handler,
		},
		{
			MethodName: "Load",
			Handler:    _Carnx_Load_Handler,
		},
		{
			MethodName: "LoadAndAttach",
			Handler:    _Carnx_LoadAndAttach_Handler,
		},
		{
			MethodName: "Unload",
			Handler:    _Carnx_Unload_Handler,
		},
		{
			MethodName: "Attach",
			Handler:    _Carnx_Attach_Handler,
		},
		{
			MethodName: "Detach",
			Handler:    _Carnx_Detach_Handler,
		},
		{
			MethodName: "IsLoaded",
			Handler:    _Carnx_IsLoaded_Handler,
		},
		{
			MethodName: "IsAttached",
			Handler:    _Carnx_IsAttached_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/carnx.proto",
}
